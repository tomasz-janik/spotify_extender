"""
    spotify_extender.request.request_handler

    This module is responsible for communication
    with Spotify API
"""
from typing import Callable
from urllib.parse import urlencode

import flask
import requests
from flask import make_response
from injector import inject
from werkzeug.utils import redirect

from spotify_extender.decorators.decorators import jsonify_response, \
    success_status_code_required, tokens_required
from spotify_extender.enums.time_range import SpotifyTimeRange
from spotify_extender.enums.top_type import SpotifyTopType
from spotify_extender.mappers import response_mapper
from spotify_extender.request.request_factory import RequestFactory
from spotify_extender.request.url_builder import UrlBuilder
from spotify_extender.session.session_facade import SessionFacade


class RequestHandler:
    """
    Handles all request to Spotify API
    """

    def __init__(self, session_facade):
        self.session_facade = session_facade

    @staticmethod
    @jsonify_response
    @success_status_code_required
    def get_tokens(code: str) -> requests.models.Response:
        """Builds and executes Spotify API call
        required to get Spotify authorization
        tokens

        :param code: string returned by Spotify while
        callback application to authorize user
        :return: response from Spotify API
        """
        url: str = UrlBuilder.get_tokens()
        auth: tuple = RequestFactory.build_auth()
        payload: dict = RequestFactory.build_tokens_request(code=code)

        return requests.post(url=url,
                             auth=auth,
                             data=payload)

    @staticmethod
    def login(state: str) -> flask.Response:
        """Builds and executes Spotify API call
        required to login user to Spotify

        :param state: string generated by
        spotify_extender. Protection from
        cross-site request forgery.
        :return: response that redirects
        user to Spotify Login page
        """
        url: str = UrlBuilder.get_authorization()
        payload: dict = RequestFactory.build_authorization_request(state)
        return make_response(redirect(f'{url}/?{urlencode(payload)}'))

    def get_top(self, time_range: SpotifyTimeRange, top_type: SpotifyTopType, offset: int) \
            -> requests.models.Response:
        """Builds and executes Spotify API call
        required to get top tracks/artists for
        user

        :param time_range: SpotifyTimeRange enum value
        representing time range that should be respected
        by Spotify API
        :param top_type: SpotifyTopType enum value
        representing whether to get top tracks or artists
        :param offset: integer representing offset
        :return: response from Spotify API
        """
        url: str = UrlBuilder.get_top(time_range, top_type, offset)
        headers: dict = RequestFactory.build_authorization_header(self.session_facade.access_token)

        return requests.get(url=url, headers=headers)

    @jsonify_response
    @success_status_code_required
    @tokens_required
    def refresh(self) -> requests.models.Response:
        """Builds and executes Spotify API call
        required to refresh authorization tokens

        :return: response from Spotify API
        """
        url: str = UrlBuilder.get_refresh()
        auth: tuple = RequestFactory.build_auth()
        headers: dict = RequestFactory.build_content_type_header()
        payload: dict = RequestFactory.build_refresh_payload(self.session_facade.refresh_token)

        return requests.post(url=url,
                             auth=auth,
                             headers=headers,
                             data=payload)


class RequestHandlerProxy(RequestHandler):
    """
    Proxy used to handle 401 Unauthorized
    response for requests
    """

    @inject
    def __init__(self, session_facade: SessionFacade):
        super().__init__(session_facade)

    @jsonify_response
    @success_status_code_required
    @tokens_required
    def get_top(self, time_range, top_type, offset: int) -> requests.models.Response:
        """Executes Spotify API call required to get top
         tracks/artists for user and handles case where
         response returns 401 code

        :param time_range: SpotifyTimeRange enum value
        representing time range that should be respected
        by Spotify API
        :param top_type: SpotifyTopType enum value
        representing whether to get top tracks or artists
        :param offset: integer representing offset
        :return: response from Spotify API
        """
        response: requests.models.Response = super().get_top(time_range, top_type, offset)
        if response.status_code == 401:
            self.__refresh_token()
            return super().get_top(time_range, top_type, offset)
        return response

    def __refresh_token(self) -> None:
        """
        Refreshes authorization tokens and saves
        them in session
        """
        response = super().refresh()
        self.session_facade['access_token'] = response['access_token']


class RequestHandlerFacade:
    """
    Facade used to make calls to Spotify API
    easier and more manageable
    """

    @inject
    def __init__(self, request_handler: RequestHandlerProxy):
        self.request_handler = request_handler

    def login(self, state) -> flask.Response:
        """Executes Spotify API call
        required to login user to Spotify

        :param state: string generated by
        spotify_extender. Protection from
        cross-site request forgery.
        :return: response that redirects
        user to Spotify Login page
        """
        return self.request_handler.login(state)

    def get_all_top(self, time_range, top_type) -> list:
        """Executes multiple Spotify API calls
        required to get all top tracks/artists
        for authorized user

        :param time_range: SpotifyTimeRange enum value
        representing time range that should be respected
        by Spotify API
        :param top_type: SpotifyTopType enum value
        representing whether to get top tracks or artists
        :return: list containing all top tracks/artists
        """
        first_batch = \
            self.request_handler.get_top(time_range, top_type, 0)['items'][:-1]
        second_batch = \
            self.request_handler.get_top(time_range, top_type, 49)['items']
        mapper: Callable = response_mapper.get_mapper(top_type)

        return [mapper(item) for item in first_batch + second_batch]

    def get_tokens(self, code: str) -> requests.models.Response:
        """Executes Spotify API call
        required to get Spotify authorization
        tokens

        :param code: string returned by Spotify while
        callback application to authorize user
        :return: response from Spotify API
        """
        return self.request_handler.get_tokens(code)
